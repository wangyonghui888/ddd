/*
 * GoldenRace External API
 * Definitions of External API for GoldenRace Java Server 
 *
 * OpenAPI spec version: 7.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.panda.sport.rcs.virtual.third.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * FTPS and FTPES Report Target
 */
@ApiModel(description = "FTPS and FTPES Report Target")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2020-09-25T13:53:10.996Z")



public class FtpsReportTarget {
  /**
   * FTP secure socket protocol name. Will be used as value \&quot;TLS\&quot; if it isn&#39;t set.
   */
  @JsonAdapter(ProtocolEnum.Adapter.class)
  public enum ProtocolEnum {
    TLS("TLS"),
    
    SSL("SSL");

    private String value;

    ProtocolEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProtocolEnum fromValue(String text) {
      for (ProtocolEnum b : ProtocolEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ProtocolEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtocolEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtocolEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtocolEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("protocol")
  private ProtocolEnum protocol = null;

  @SerializedName("isImplicit")
  private Boolean isImplicit = null;

  /**
   * Data Channel Protection Level. Will be used as value \&quot;CLEAR\&quot; if it isn&#39;t set. | Type         | PROT | Description                                   | | ------------ | ---- | --------------------------------------------- | | CLEAR        | C    | Neither Integrity nor Privacy                 | | SAFE         | S    | Integrity without Privacy                     | | CONFIDENTIAL | E    | Privacy without Integrity (SSL protocol only) | | PRIVATE      | P    | Integrity and Privacy                         | 
   */
  @JsonAdapter(ProtEnum.Adapter.class)
  public enum ProtEnum {
    CLEAR("CLEAR"),
    
    SAFE("SAFE"),
    
    CONFIDENTIAL("CONFIDENTIAL"),
    
    PRIVATE("PRIVATE");

    private String value;

    ProtEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static ProtEnum fromValue(String text) {
      for (ProtEnum b : ProtEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<ProtEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ProtEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public ProtEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return ProtEnum.fromValue(String.valueOf(value));
      }
    }
  }

  @SerializedName("prot")
  private ProtEnum prot = null;

  @SerializedName("useClientMode")
  private Boolean useClientMode = null;

  @SerializedName("sessionCreation")
  private Boolean sessionCreation = null;

  @SerializedName("needClientAuth")
  private Boolean needClientAuth = null;

  @SerializedName("wantsClientAuth")
  private Boolean wantsClientAuth = null;

  public FtpsReportTarget protocol(ProtocolEnum protocol) {
    this.protocol = protocol;
    return this;
  }

   /**
   * FTP secure socket protocol name. Will be used as value \&quot;TLS\&quot; if it isn&#39;t set.
   * @return protocol
  **/
  @ApiModelProperty(value = "FTP secure socket protocol name. Will be used as value \"TLS\" if it isn't set.")
  public ProtocolEnum getProtocol() {
    return protocol;
  }

  public void setProtocol(ProtocolEnum protocol) {
    this.protocol = protocol;
  }

  public FtpsReportTarget isImplicit(Boolean isImplicit) {
    this.isImplicit = isImplicit;
    return this;
  }

   /**
   * FTP secure mode. Will be used as value \&quot;false\&quot; (explicit) if it isn&#39;t set.
   * @return isImplicit
  **/
  @ApiModelProperty(value = "FTP secure mode. Will be used as value \"false\" (explicit) if it isn't set.")
  public Boolean isIsImplicit() {
    return isImplicit;
  }

  public void setIsImplicit(Boolean isImplicit) {
    this.isImplicit = isImplicit;
  }

  public FtpsReportTarget prot(ProtEnum prot) {
    this.prot = prot;
    return this;
  }

   /**
   * Data Channel Protection Level. Will be used as value \&quot;CLEAR\&quot; if it isn&#39;t set. | Type         | PROT | Description                                   | | ------------ | ---- | --------------------------------------------- | | CLEAR        | C    | Neither Integrity nor Privacy                 | | SAFE         | S    | Integrity without Privacy                     | | CONFIDENTIAL | E    | Privacy without Integrity (SSL protocol only) | | PRIVATE      | P    | Integrity and Privacy                         | 
   * @return prot
  **/
  @ApiModelProperty(value = "Data Channel Protection Level. Will be used as value \"CLEAR\" if it isn't set. | Type         | PROT | Description                                   | | ------------ | ---- | --------------------------------------------- | | CLEAR        | C    | Neither Integrity nor Privacy                 | | SAFE         | S    | Integrity without Privacy                     | | CONFIDENTIAL | E    | Privacy without Integrity (SSL protocol only) | | PRIVATE      | P    | Integrity and Privacy                         | ")
  public ProtEnum getProt() {
    return prot;
  }

  public void setProt(ProtEnum prot) {
    this.prot = prot;
  }

  public FtpsReportTarget useClientMode(Boolean useClientMode) {
    this.useClientMode = useClientMode;
    return this;
  }

   /**
   * Configures the socket to use client (or server) mode in its first. Will be used as value \&quot;true\&quot; if it isn&#39;t set.
   * @return useClientMode
  **/
  @ApiModelProperty(value = "Configures the socket to use client (or server) mode in its first. Will be used as value \"true\" if it isn't set.")
  public Boolean isUseClientMode() {
    return useClientMode;
  }

  public void setUseClientMode(Boolean useClientMode) {
    this.useClientMode = useClientMode;
  }

  public FtpsReportTarget sessionCreation(Boolean sessionCreation) {
    this.sessionCreation = sessionCreation;
    return this;
  }

   /**
   * Controls whether a new SSL session may be established by this socket. Will be used as value \&quot;true\&quot; if it isn&#39;t set.
   * @return sessionCreation
  **/
  @ApiModelProperty(value = "Controls whether a new SSL session may be established by this socket. Will be used as value \"true\" if it isn't set.")
  public Boolean isSessionCreation() {
    return sessionCreation;
  }

  public void setSessionCreation(Boolean sessionCreation) {
    this.sessionCreation = sessionCreation;
  }

  public FtpsReportTarget needClientAuth(Boolean needClientAuth) {
    this.needClientAuth = needClientAuth;
    return this;
  }

   /**
   * Configures the socket to require client authentication. Will be used as value \&quot;false\&quot; if it isn&#39;t set.
   * @return needClientAuth
  **/
  @ApiModelProperty(value = "Configures the socket to require client authentication. Will be used as value \"false\" if it isn't set.")
  public Boolean isNeedClientAuth() {
    return needClientAuth;
  }

  public void setNeedClientAuth(Boolean needClientAuth) {
    this.needClientAuth = needClientAuth;
  }

  public FtpsReportTarget wantsClientAuth(Boolean wantsClientAuth) {
    this.wantsClientAuth = wantsClientAuth;
    return this;
  }

   /**
   * Configures the socket to request client authentication, but only if such a request is appropriate to the cipher suite negotiated. Will be used as value \&quot;false\&quot; if it isn&#39;t set.
   * @return wantsClientAuth
  **/
  @ApiModelProperty(value = "Configures the socket to request client authentication, but only if such a request is appropriate to the cipher suite negotiated. Will be used as value \"false\" if it isn't set.")
  public Boolean isWantsClientAuth() {
    return wantsClientAuth;
  }

  public void setWantsClientAuth(Boolean wantsClientAuth) {
    this.wantsClientAuth = wantsClientAuth;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FtpsReportTarget ftpsReportTarget = (FtpsReportTarget) o;
    return Objects.equals(this.protocol, ftpsReportTarget.protocol) &&
        Objects.equals(this.isImplicit, ftpsReportTarget.isImplicit) &&
        Objects.equals(this.prot, ftpsReportTarget.prot) &&
        Objects.equals(this.useClientMode, ftpsReportTarget.useClientMode) &&
        Objects.equals(this.sessionCreation, ftpsReportTarget.sessionCreation) &&
        Objects.equals(this.needClientAuth, ftpsReportTarget.needClientAuth) &&
        Objects.equals(this.wantsClientAuth, ftpsReportTarget.wantsClientAuth);
  }

  @Override
  public int hashCode() {
    return Objects.hash(protocol, isImplicit, prot, useClientMode, sessionCreation, needClientAuth, wantsClientAuth);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FtpsReportTarget {\n");
    
    sb.append("    protocol: ").append(toIndentedString(protocol)).append("\n");
    sb.append("    isImplicit: ").append(toIndentedString(isImplicit)).append("\n");
    sb.append("    prot: ").append(toIndentedString(prot)).append("\n");
    sb.append("    useClientMode: ").append(toIndentedString(useClientMode)).append("\n");
    sb.append("    sessionCreation: ").append(toIndentedString(sessionCreation)).append("\n");
    sb.append("    needClientAuth: ").append(toIndentedString(needClientAuth)).append("\n");
    sb.append("    wantsClientAuth: ").append(toIndentedString(wantsClientAuth)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

